---
description: 
globs: 
alwaysApply: true
---
# Ringable: Implementation and Design Guide

## Introduction  
**Ringable** is a client-side anonymous voting platform that leverages ring signatures to protect voter anonymity. It allows a user to prove they belong to an approved group of voters without revealing which individual in the group cast a given vote ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=library)). By using the Nostringer ring signature scheme compiled to WebAssembly, Ringable ensures that votes are verifiable as coming from one of the authorized public keys, yet unlinkable to any specific key. This is ideal for scenarios requiring collective decisions without exposing identities ([Ring Signatures based anonymous voting | Devpost](https://devpost.com/software/ring-signatures-based-anonymous-voting#:~:text=As%20an%20example%20we%27ve%20made,for%20our%20own%20contract%20constructors)). The platform’s MVP is entirely client-side—there is **no backend server**. Data (like user keys, rings, proposals, and votes) is stored in-browser (using `localStorage`) and managed via Zustand state to persist across sessions. 

In addition to strong privacy, Ringable features a distinctive **retro game-inspired pixel-art design**. The UI adopts a nostalgic 8-bit aesthetic (e.g. pixelated icons, blocky fonts, limited color palette) while maintaining modern usability. The combination of cutting-edge cryptography (ring signatures) with a playful vintage interface makes Ringable both secure and engaging. 

**Tech Stack Overview:** We use a **Turborepo monorepo** to structure the project. This provides a Next.js frontend app and shared packages for UI components and utilities ([turborepo/examples/with-tailwind/README.md at main · vercel/turborepo · GitHub](https://github.com/vercel/turbo/blob/main/examples/with-tailwind/README.md#:~:text=,s%20used%20throughout%20the%20monorepo)). All code is written in TypeScript. **Zustand** manages application state (with persistence to localStorage for offline use), and the **Nostringer** Rust library (via WebAssembly) provides cryptographic functions for ring signatures. The focus is on the **bLSAG** variant of ring signatures (Back’s Linkable Spontaneous Anonymous Group) which produces a linkable *key image* per private key to detect duplicate votes ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=A%20linkable%20variant%20that%3A)). In other words, while all votes remain anonymous, the system can tell if the *same* person voted more than once, preventing double-voting. 

This guide will detail the project structure, module implementation, integration of the Nostringer WASM, and the design system for the retro UI. By the end, you should have a clear blueprint for building **Ringable**: from generating voter keys and rings, to signing and verifying anonymous votes, all wrapped in a polished pixel-art interface.

## Project Setup and Structure  

This yields a repository with multiple apps and packages ([turborepo/examples/with-tailwind/README.md at main · vercel/turborepo · GitHub](https://github.com/vercel/turbo/blob/main/examples/with-tailwind/README.md#:~:text=,s%20used%20throughout%20the%20monorepo)): 

- **apps/web** – The Next.js frontend application for Ringable (our main app where pages and components reside). It comes pre-configured with Tailwind CSS for styling. (The template also includes an `apps/docs` Next.js app, which you could repurpose for documentation or demos, though it’s optional for the MVP.)  
- **packages/ui** – A shared UI components library. We will build our retro-styled React components here (buttons, modals, cards, etc.) using Tailwind classes. This package is consumed by the web app for a consistent design across the project.  
- **packages/crypto** – A custom utility package for cryptography (we will create this). It will wrap Nostringer’s WebAssembly module, providing convenient functions to generate keys, sign votes, and verify signatures. By isolating crypto logic here, our app code stays clean.  
- **packages/types** (optional) – A shared types/models package. We can define TypeScript interfaces for things like `Proposal`, `Vote`, or `RingMember` to ensure consistency across app and packages. (For a small project, types can also live in the app, but a package makes them reusable).  
- **packages/eslint-config**, **packages/tsconfig** – Shared configurations for linting and TypeScript, already set up by the Turborepo starter ([turborepo/examples/with-tailwind/README.md at main · vercel/turborepo · GitHub](https://github.com/vercel/turbo/blob/main/examples/with-tailwind/README.md#:~:text=%2A%20%60%40repo%2Feslint,s%20used%20throughout%20the%20monorepo)).  

The monorepo structure makes it easy to maintain clear separation of concerns. For example, cryptographic logic can be tested and updated in isolation (in the `crypto` package) without touching UI code, and vice versa. All packages are 100% TypeScript and can be imported into the Next.js app as needed ([turborepo/examples/with-tailwind/README.md at main · vercel/turborepo · GitHub](https://github.com/vercel/turbo/blob/main/examples/with-tailwind/README.md#:~:text=%2A%20%60%40repo%2Feslint,s%20used%20throughout%20the%20monorepo)). The Next.js app will handle the pages, routing, and overall integration of the pieces. 

**Frontend Architecture:** The Ringable web app will use Next.js routing to separate concerns: 

- **Home / Proposals List Page:** Lists all created proposals (from local storage) and their status (open/closed). From here users can create a new proposal or select an existing one to vote or view results.  
- **Create Proposal Page:** A form for proposal details – title/question, voting options, and selection of the ring (which group of public keys can vote). This page uses components like TextInput, OptionList, and a Submit Button. On submit, the new proposal (with its ring members and options) is saved to state/storage.  
- **Proposal Details Page:** Shows a specific proposal. If it’s open and the current user’s public key is one of the ring members, it will display the voting UI (the list of options with a Vote button). If the user already voted, or if the proposal is closed, it may display a notice or simply the results. Votes from any participants (collected via local state for our MVP) are shown here once the proposal is closed or as they come in.  
- **Settings / Key Management Page:** Allows the user to manage their identity and rings. This is where they create or load their keypair and manage ring members. (Alternatively, these functions could be split into a couple of screens: e.g., a **Profile** screen for the user’s key, and a **Ring Management** screen for managing lists of authorized voters. For simplicity, we can use a single page with sections for each.)  

All pages share common layout elements that fit the retro theme (e.g. a header with the app title in pixel font, and a container with a pixelated border). Navigation between pages can be via Next’s Link component (e.g. a “New Proposal” button link, or links to settings). 

**State Management:** We use **Zustand** to handle state across components without prop drilling. Zustand is lightweight and suits our needs for a few global stores (for user data, proposals, etc.). Notably, we enable Zustand’s `persist` middleware so that store data is saved to `localStorage` automatically ([zustand/docs/integrations/persisting-store-data.md at main · pmndrs/zustand · GitHub](https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#:~:text=The%20Persist%20middleware%20enables%20you,thus%20persisting%20its%20data)). This means the user’s keypair, rings, and proposals will persist between page reloads – essential since we have no server database. Zustand persist makes it easy to hydrate state from storage on app load, providing a seamless offline experience (the state rehydrates when the app loads, since by default it uses localStorage to store a JSON dump of your state ([zustand/docs/integrations/persisting-store-data.md at main · pmndrs/zustand · GitHub](https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#:~:text=20))). We’ll create separate store slices for different domains: 

- **UserStore:** Holds the current user’s keypair (public & private key), and possibly a flag for “is my key included in rings by default” (the *toggle Ring Member* setting, explained in User Management below). This store also keeps any user-specific preferences. It uses `persist({ name: 'ringable-user' })` so that keys aren’t lost on refresh. **Note:** In a real app, the private key should be protected – for MVP we store it in plaintext in localStorage for simplicity, but you might later encrypt it with a passphrase. 
- **RingStore:** Manages rings (groups of public keys). It could be part of UserStore (since rings are defined by the user) or separate. A ring in state can be represented as an object with an id, name, and an array of member public keys. We allow creating, updating (adding/removing a key), and deleting rings. This store is persisted as well (`name: 'ringable-rings'`). If it’s simpler, we can merge RingStore into UserStore as just a list of rings owned by the user. 
- **ProposalsStore:** Holds all proposals created on this client. Each proposal object includes an id, title, options list, ring (reference to the list of pubkeys eligible to vote), status (open or closed), and votes (which could be an array of vote records or just a tally per option). We persist this too (`name: 'ringable-proposals'`) so that proposals don’t disappear on reload.  

Each Zustand store is defined in its own file (e.g. `useUserStore.ts`) and provides setter actions for updating state (e.g. `setKeyPair`, `addRing`, `addProposal`, `castVote`, etc.). Components will use these via hooks (e.g. `const key = useUserStore(s => s.publicKey)` to get data, or call actions to update). 

## Nostringer WASM Integration (Ring Signatures in WebAssembly)  
One of the core integrations in Ringable is the **Nostringer** ring signature library, compiled to WebAssembly. Nostringer implements Spontaneous Anonymous Group signatures (SAG) and the linkable variant bLSAG using secp256k1 (the curve used in Bitcoin and Nostr) ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=library)). We use it to let users sign votes anonymously as a member of a ring of keys. The **WebAssembly build** of Nostringer allows us to run the cryptographic code in the browser at near-native speed, which is critical for performance and for using Rust’s battle-tested crypto implementations. 

**Obtaining the WASM artifact:** The Nostringer project provides a Rust crate and instructions to compile to WASM. We can either build it ourselves or use a precompiled artifact if available. To build, ensure you have `wasm-pack` installed (`cargo install wasm-pack`) and run `wasm-pack build --target web --features wasm` in the Nostringer source ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=To%20compile%20Nostringer%20for%20WebAssembly%3A)). This produces files such as `nostringer_bg.wasm` (the WebAssembly binary), `nostringer.js` (a JS wrapper that loads the WASM and exposes functions), and `nostringer.d.ts` (TypeScript type definitions for the exported functions). For Ringable, we include these files in, say, `packages/crypto/wasm/` or directly in the `public/` directory of the web app so they can be fetched. (If the Nostringer authors publish the WASM as an npm package, one could simply install and import it. Assuming we have the files manually, we’ll proceed with manual integration.)

**Loading the WASM module:** In our crypto package, we create a module (e.g. `nostringer.ts`) that encapsulates initialization and usage. We use dynamic import to bring in the module only on the client side (Next.js should not attempt to SSR this). For example: 

```ts
// packages/crypto/src/nostringer.ts
let initialized = false;

export async function initNostringer() {
  if (initialized) return;
  const { default: init, 
          wasm_generate_keypair, 
          wasm_sign, wasm_verify, 
          wasm_sign_blsag, wasm_verify_blsag,
          wasm_key_images_match } = await import('../../public/nostringer.js');
  await init(); // loads the WASM
  initialized = true;
  // store references or re-export the functions as needed
  return { wasm_generate_keypair, wasm_sign_blsag, wasm_verify_blsag, wasm_key_images_match };
}
``` 

This snippet dynamically imports the `nostringer.js` (which in turn will load `nostringer_bg.wasm`). The Nostringer JS provides several functions we’ll use, as seen above: `wasm_generate_keypair`, `wasm_sign_blsag`, `wasm_verify_blsag`, etc. ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=import%20init%2C%20,nostringer.js)). We call the default `init()` function it exports to actually initialize the WebAssembly module in memory ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=%2F%2F%20Initialize%20the%20WASM%20module,await%20init)). After that, we can call the cryptography functions directly in JavaScript/TypeScript.

**Using Nostringer functions:** Once `initNostringer()` is done (we might call this once at app startup or before the first cryptographic operation), we can: 

- **Generate Keypair:** Use `wasm_generate_keypair("xonly")` to create a new secp256k1 keypair. (“xonly” indicates we want the public key in 32-byte compressed format as used in Nostr). This returns a keypair object with methods like `.public_key_hex()` and `.private_key_hex()` to get the keys as hex strings ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=%2F%2F%20Generate%20keypairs%20for%20the,xonly)). In our User Management flow, we’ll call this to create a new identity for the user. We then store the hex strings in Zustand (and localStorage). 
- **Sign (bLSAG variant):** To cast a vote anonymously, we use the **bLSAG** signing function. Nostringer provides `wasm_sign_blsag(message, privateKeyHex, ringPublicKeysArray)`. Here `message` is a byte array of the data to sign (our vote), the private key is the hex string of the user’s secret key, and `ringPublicKeysArray` is an array of hex public keys comprising the ring (including the user’s key and others). The output is a signature (likely in some serialized format, e.g. a hex string or Uint8Array). This signature internally includes a **key image** – a unique identifier for the private key’s use in this ring signature ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=,will%20produce%20different%20key%20images)). We’ll store the signature with the vote.  
- **Verify (bLSAG):** To check a vote, we use `wasm_verify_blsag(signature, message, ringPublicKeysArray)`, which returns a boolean indicating if the signature is valid for that message and ring. Verification uses the public keys and will confirm that the signature was indeed produced by one of them (without telling which). We will run this when processing votes to ensure they are valid before counting them. Because the app is client-only, verification is more of a demonstration (in a real deployment, verification would be done by a server or by other clients). Still, for integrity we can verify each vote signature upon submission and again when displaying results. 
- **Detecting Duplicate Votes:** bLSAG’s key image makes it possible to detect if the *same key* signed more than one message ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=A%20linkable%20variant%20that%3A)). Nostringer offers `wasm_key_images_match(sig1, sig2)` which compares the key images of two signatures ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=wasm_sign%2C%20wasm_verify%2C%20wasm_sign_blsag%2C%20wasm_verify_blsag%2C%20wasm_key_images_match%2C)). If the key images are equal, it means the same private key generated both signatures (i.e., the same voter voted twice). We will use this function when recording votes: if a new vote’s key image matches any existing vote for that proposal, we know it’s a double-vote attempt. In an open network, we’d reject or mark the second vote. In our MVP, since each user essentially controls one key locally, we’ll primarily rely on UI (disabling the vote button after voting) to prevent duplicates, but we can still demonstrate this check if simulating multiple votes. For example, if multiple votes are stored, we can run through them to ensure no duplicates – important if in the future votes come from multiple clients.  

**Types and Developer Experience:** Because we have `nostringer.d.ts`, we can include it for type-safe usage of these functions (ensuring we pass correct types, etc.). We might augment our crypto package with higher-level functions, for instance: `generateUserKey(): {publicKey: string, privateKey: string}` that wraps `wasm_generate_keypair`, or `signVote(choice: string, proposalId: string): string` that internally formats the message and calls `wasm_sign_blsag`. By centralizing these, the rest of the app can stay abstracted from the low-level details. For instance, we might define the message to sign as a combination of proposal ID and choice (to uniquely identify the vote intent). 

Finally, remember to only call these WASM functions after ensuring `await initNostringer()` has completed. One strategy is to call `initNostringer()` once on app load (perhaps in a custom `<App>` component or in a React context/provider that wraps the app). This will make the crypto functions ready to use in any component. Alternatively, call it on-demand in actions (e.g., in the vote action, check `initialized` flag and init if not). 

## Functional Modules and Implementation  

Now, let’s break down the key functional modules of Ringable and how to implement each, tying together state, crypto, and UI. The five core modules are **User Management**, **Ring Management**, **Proposal Creation**, **Voting**, and **Results**. Each corresponds to a set of features and likely a section of the UI.

### 1. User Management  
This module handles the user’s identity and preferences. In Ringable’s context, a “user” is essentially a cryptographic identity (keypair) that will participate in rings. Features include creating or loading a keypair, viewing one’s public key (to share with others if needed), and a setting to toggle whether the user’s own key is included in rings by default. 

**Keypair Generation & Storage:** When the user first opens the app, if no keypair is present in local storage, we prompt them to create one. This uses `wasm_generate_keypair("xonly")` to produce a new secp256k1 keypair ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=%2F%2F%20Generate%20keypairs%20for%20the,xonly)). We immediately save the hex strings to the UserStore state and persist them. The UI can show the public key (as a hex string) and perhaps a copy-to-clipboard button, so the user can share it with others who might need to add them to a voting ring. If a keypair already exists in localStorage (from a previous session), our Zustand persist will have rehydrated it – the app can skip the generation step and go straight to showing the user’s identity. Optionally, we allow **loading an existing keypair**: e.g., the user pastes a hex private key (64 hex chars). We’d validate its format and derive the public key (perhaps by calling a Nostringer util if available, or using the generate function with a specific seed). This way, a user can port their identity from another device. After loading, we update state and persist. 

**Toggle “Ring Member” Setting:** This addresses whether the user’s own key is included in a ring of voters. In some votes, the organizer (user) might not be voting; in others, they might. We provide a simple toggle (e.g., a checkbox labeled “Include me as a voter in new proposals”). If enabled, whenever the user creates a proposal, their public key will automatically be added to the ring members list. If disabled, the ring will exclude their key unless they explicitly add it in Ring Management. This preference is stored in UserStore (e.g., `userStore.isMember = true/false`). This toggle can be surfaced in the UI as part of the user profile settings. It’s essentially a convenience; the user can still manually adjust ring members for each proposal, but it’s good to have a default behavior. 

Because all user data is kept client-side, we ensure it persists: thanks to Zustand’s storage, the keypair and toggle persist under a unique storage key (like “ringable-user”) ([zustand/docs/integrations/persisting-store-data.md at main · pmndrs/zustand · GitHub](https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#:~:text=20)). This way, the user doesn’t have to regenerate or re-toggle every time. 

**Security Considerations:** Remind the user to backup their private key if needed (since if they clear local storage, the keypair could be lost unless they saved it externally). For MVP we won’t implement any complex key backup or encryption, but we do provide the tools for the user to manage their keys responsibly (e.g., show the private key with a warning so they can write it down). 

On the UI side, the **Settings/Profile page** contains this information and controls. For example: 

- A section showing “**Your Identity**: Public Key (hex) … [Copy]” and maybe a button “[Generate New Key]” or “[Import Key]” (with a modal to input a key). 
- The “Include me in rings” checkbox. 
- Possibly a list of rings the user is part of (which overlaps with Ring Management). 

### 2. Ring Management  
Ring Management focuses on defining the group of public keys that constitute an anonymous voting group (the “ring”). In practice, when creating a proposal, the user must specify the set of eligible voters (each identified by a public key). This module lets the user manage those sets globally, rather than re-enter keys each time. 

**Ring Members List:** The simplest approach is to maintain one list of known public keys (besides the user’s own) that can be quickly included as voters. For example, a user could add the public keys of colleagues, friends, or other participants in their voting group. However, often we want multiple distinct rings for different contexts (e.g., a “Team Ring” vs. an “External Advisors Ring”). Thus, we support **multiple rings**, each with its own name and member list. 

Using our RingStore, the user can **create a new ring** by giving it a name and adding members. A ring member is just a public key (and perhaps an associated label for convenience, e.g., “Alice’s key”). The UI would have an interface to add a member: a text input for a new public key (hex) and an “Add” button. We should validate the input (proper hex length). If using Nostr keys (32-byte hex), we ensure it’s 64 hex chars. Members are displayed in a list with options to remove them. Removing a member simply deletes that public key from the ring’s array. 

The user can manage multiple rings – perhaps shown as a list of ring cards, each card showing the ring name and count of members, and an expand/collapse to view the members. Each ring is stored in our Zustand RingStore with an ID. 

**Including the User’s Key:** If the user’s “include me” toggle is on (from User Management), we might visually mark their own key in lists or automatically insert it when a ring is used for a proposal. We might not always include the user’s key in the stored ring definition (to keep rings generic), instead adding it during proposal creation if needed. It’s up to design: one approach is to allow the user to add themselves explicitly to any ring (since they also have a public key). For clarity, the interface might show a button “Add My Key” in the ring editor, which is essentially a shortcut to add their pubkey. This is the manual analog to the global toggle (which could even auto-add them behind the scenes for new rings). 

All ring data is persisted in localStorage (e.g., under `ringable-rings` key). This way, previously defined rings are available for new proposals in future sessions. 

**Using Rings in Proposals:** When the user goes to create a proposal, they should pick which ring of voters to use. The Create Proposal form can have a dropdown or selector for “Eligible Voters” – listing the names of rings they have. For example, if they created a ring named “Core Team” with 5 members, they can select that for a new vote. Alternatively, provide an option to define a custom ring on the spot (perhaps by adding keys in a multiselect). To keep MVP simple, it’s fine to require that a ring is pre-defined in the Ring Management section before it can be used in a proposal. 

From an implementation standpoint, when a ring is selected for a proposal, we will copy that ring’s public key list into the proposal object (so that if the user later changes the ring definition, it doesn’t retroactively affect past proposals). Essentially, the proposal will carry its own list of pubkeys as the ring used for that vote. (We can store just the keys, or reference the ring by ID and resolve it, but copying at creation time may be safer for immutability of past data.) 

### 3. Proposal Creation  
Proposal Creation is the workflow for defining a new vote. A **Proposal** in Ringable includes: a title or question, a set of voting options, the ring of authorized voters, and a status (open or closed). For MVP, we assume all votes are single-choice (each voter picks one of the provided options) and the goal is to see which option gets how many votes. We won’t implement complex tallying or multiple-choice in this first iteration. 

On the **Create Proposal page**, we present a form: 

- **Title** – A short question or description of what is being voted on (e.g., “Which venue for the annual meetup?”).  
- **Options** – A list of possible choices. The UI can start with two option fields by default and allow the user to add more (e.g., an “Add option” button that adds a new text field for an additional choice). Options are just strings. We might limit the number of options for UI sanity (perhaps 2–5 options). 
- **Eligible Ring** – As discussed, a dropdown or selector to choose which ring of public keys will be allowed to vote. If the user hasn’t created any rings yet, we need to allow defining the ring here. Perhaps we show a multi-line text area or multiple inputs to paste in pubkeys, or direct the user to Ring Management to set up a ring first. We can also have a simple default ring of just the user’s key if nothing else is set (for testing or if they just want to see how it works alone). In any case, the ring selection is required. If the user’s toggle was on, we might auto-check including their key: ensure that if their pubkey isn’t already in the selected ring, we include it now if they intend to vote as well. The final ring that will be used (list of pubkeys) is assembled at this step. 
- Possibly **Status** – The status will initially be “Open” (meaning voting is allowed). We don’t need the user to choose this on creation; it will default to open and later can be closed manually (in the Results stage or via a button on the proposal page when they decide to stop voting). 

When the user submits the form, we create a new proposal object, assign it a unique ID (could be a simple increment or a UUID), and save it to the ProposalsStore. For example: 

```ts
const newProposal: Proposal = {
  id: nanoid(), 
  title,
  options: [{ text: "Option1", votes: 0 }, { text: "Option2", votes: 0 }, ...],
  ring: [...arrayOfPubKeys], 
  status: "open",
  votes: [] // to store signature entries or just count, see below
};
addProposal(newProposal);
```

We might store `votes` as an array of objects like `{ pubkey: string (optional), signature: string }` if we wanted to keep each vote record. However, since anonymity is key, we specifically do **not** tie the vote to a pubkey (that’s the whole point!). Instead, each vote record might contain only the signature and perhaps the selected option. But because the signature itself proves the vote came from a ring member, we don’t need to store the pubkey. We could store votes as `{ optionIndex: number, signature: string }`. Alternatively, we simply store a tally count per option, but then we lose the ability to verify each signature later or detect duplicates in a rigorous way. A good compromise: store each signature and the chosen option. That way, the Results module can verify all signatures and count them. So, `votes: VoteRecord[]` where `VoteRecord` has `{ choiceIndex: number, signature: string }`. 

After creation, the app navigates to the Proposal Details page for that proposal (or back to home with the list). The new proposal appears in the list of proposals (with status Open). 

### 4. Voting  
The Voting module is the heart of Ringable’s functionality – it allows a user to cast an anonymous vote on a proposal, producing a ring signature that others can verify. This involves the cryptographic signing via Nostringer and updating the state with the vote. 

On the **Proposal Details page** (for an open proposal), if the current user’s public key is in that proposal’s ring, we present the **voting UI**. This could be as simple as radio buttons or a list of options with a Vote button: e.g., a list of option cards that the user can click, highlighting their selection, and a “Submit Vote” button. If the user’s key is not in the ring, we inform them they are not eligible to vote on this proposal (and only show results if any). If the proposal is closed, we don’t allow voting, only show results. 

When the user selects an option and hits **Vote**: 

- We retrieve the proposal’s ring public keys array (from the proposal state). 
- We get the user’s private key from the UserStore. (If somehow the user doesn’t have one loaded, we’d prompt them to set up their key – but normally they would have done so in User Management.) 
- We form the message to sign. A simple approach is to concatenate the proposal ID and the chosen option index or text. For example, message = `proposalId|choiceIndex`. It’s critical that everyone verifies the same message that was signed. Using the proposal ID ensures uniqueness to that proposal. (We could also include the proposal title or option text, but ID + index is enough and avoids any ambiguity or special characters issues.) We then convert this string to a `Uint8Array` (using `TextEncoder`). 
- We call `wasm_sign_blsag(messageBytes, userPrivateKeyHex, ringPubKeysArray)` which returns a signature (likely as a Uint8Array or hex string). Let’s assume it gives a hex string for the signature. This operation generates the ring signature and an embedded key image ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=,will%20produce%20different%20key%20images)). 
- Optionally, immediately call `wasm_verify_blsag(signature, messageBytes, ringPubKeysArray)` to double-check it verifies to true (especially during development to ensure everything is correct). In a production setting, you might skip local verify to save time and just assume it’s correct, since the cryptography is presumably reliable. But for demonstration, we can verify and maybe log the result or show an alert if something’s off. 
- We then update the proposal’s state: push a new `VoteRecord` with the chosen option index and signature. We also increment the vote count for that option (if we maintain a separate tally). If we only derive tallies from the votes array, we can compute counts on the fly in Results. But for quick display, it’s fine to also maintain a `votesCount` array parallel to options. 

After casting a vote, we **prevent duplicate voting** from this user. The simplest way: once the user has voted, hide or disable the vote UI, perhaps replacing it with a message “You have voted for Option X.” This is a UX step. However, beyond just UI, thanks to bLSAG we can ensure no double vote goes unrecognized: before adding a new vote, we compare its key image to existing ones. Using `wasm_key_images_match`, we could iterate over existing `proposal.votes` signatures and check if the new signature’s key image matches any prior ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=,signature%20scheme%20used%20in%20Monero)). If a match is found, it means the same user (private key) already voted. In that case, we would reject the new vote — in a multi-user scenario this prevents a user with the same key voting twice from different devices. In our single-client MVP, this scenario might only happen if the user somehow tried to vote twice (which our UI disallows) or if two different private keys somehow produce the same key image (should not happen if keys are different). So this is more future-proofing. We log or mark if a duplicate was detected. 

From the perspective of other participants: Since we have no server, we aren’t actually broadcasting the vote to others. In a real deployment, you might post the signature to a backend or to a Nostr event so that other clients can pick it up and update results. For the MVP, we assume a single user may simulate multiple voters by manually adding multiple keys to a ring and perhaps even importing those private keys one by one to cast votes (for testing). Each time, as long as they switch the active private key in User Management and cast a vote, we’ll collect multiple signatures in the proposal. This is a bit contrived, but it’s a way to test the multi-vote scenario locally. In any case, the Results module will operate on whatever votes have been recorded in the proposal’s state. 

Before moving on, **verify cryptographic properties**: Each ring signature should be unlinkable except via the key image. That means if the same person voted twice, those two signatures would share a key image (linkable), but any two votes from different keys should not appear linkable (and indeed `wasm_key_images_match` would return false for different voters). We rely on Nostringer’s correctness here. We can trust that verifying each signature with the ring returns true only for valid ones, and that a given private key always produces the same key image for a given ring (that’s how linkability works) ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=,will%20produce%20different%20key%20images)). 

### 5. Results and Verification  
The Results module handles displaying the outcome of the vote and ensuring its integrity. Once a proposal is marked **Closed** (meaning no further voting is allowed), we can consider the final votes and present statistics. In our UI, we may allow the creator to manually close voting when ready (e.g., a “Close Voting” button on the proposal page). Closing simply sets `proposal.status = 'closed'`, which we could also mark automatically after a certain time, but manual control is fine for MVP. When a proposal is closed, the voting UI is replaced entirely by the results view. (Even if not closed, we might show partial results to the creator in real time, but generally secret ballots often hide results until the end. We can decide on this behavior; showing interim results is optional. Here we’ll focus on final results.) 

**Displaying Results:** At minimum, show each option with the number of votes it received. If we stored a vote count per option, we can display those numbers directly. If we stored individual vote records, we will count how many records have `choiceIndex == i` for each option i. We can compute this on render or maintain it in state. A nice touch is to show a percentage or a simple bar representing the votes. For example, if Option A got 2 votes and Option B got 3, we show bars of length proportional to these values. The style can still be retro (e.g., ASCII-like bars or pixelated progress bars). Also display the total number of votes cast and possibly the ring size (e.g., “5 votes out of 5 eligible” or “Turnout: 5/5”). That gives context on whether everyone voted or not. (Since ring members are known, we know the maximum votes possible.) 

**Verification of Votes:** Because anonymity might raise the question of “are these votes legitimate?”, we include a verification step. We can programmatically verify each signature against the ring: iterate over `proposal.votes`, and for each do `wasm_verify_blsag(v.signature, message, ringPubKeys)`. All should return true if everything went well. If any fail (which would indicate tampering or error), we could flag that vote as invalid in the UI (though in our controlled environment that shouldn’t happen). Also use `wasm_key_images_match` pairwise to ensure no duplicates if you want to double-check after closure. Essentially, the app itself can audit the results. We might not expose all this to the user in the interface (since it should “just work”), but for transparency we could have an advanced section like “Verification Log” that says “5 votes verified. No duplicates detected. All signatures valid.” This could be useful for demonstrating trustlessness in the absence of a central authority. 

**Closing the loop:** If we wanted, we could allow the user to export the results – for example, copying out the list of signatures so an external party could verify them independently with the public keys. However, that’s beyond our current scope. For now, results are viewed within the app. 

Finally, the results screen should fit the retro theme – perhaps show a “Game Over” or “Vote Complete” style message. It’s largely a presentation layer on top of the tallied data. The user can navigate back to Home to see all proposals (with this one marked closed and maybe an option to view results again). The data remains in local storage so they can reopen the app later to review past proposals and outcomes. 

## Design System: Retro Pixel-Art Style  
One of Ringable’s unique aspects is its **pixel-art retro game aesthetic**. The design is inspired by 8-bit and 16-bit era video games, which means embracing low-resolution charm while still being clear and user-friendly. We want the interface to evoke nostalgia (think NES or SNES menus, old RPG dialogue windows) yet remain polished in terms of UX (no jagged scrolling or illegible text). 

Key elements of our retro design system: 

- **Pixelated Typography:** We use a pixel-style font for titles and interface text to immediately convey the retro vibe. A great choice is **Press Start 2P**, a font that emulates old arcade text and is commonly used in NES-style designs ([raw.githubusercontent.com](https://raw.githubusercontent.com/nostalgic-css/NES.css/develop/.github/README-zh-CN.md#:~:text=via%20CDN%20,Press%20Start%202P%5D%28https%3A%2F%2Ffonts.google.com%2Fspecimen%2FPress%2BStart)). This font is available on Google Fonts. We can set it as the primary font in our Tailwind theme (or apply it to headings and certain UI elements while maybe using a more standard font for long paragraphs if needed). Be aware Press Start 2P is all uppercase and monospaced, which adds authenticity but can be harder to read in large blocks – so we will keep most text short and to-the-point (which fits a UI context). Another option is **Kongtext** or other 8-bit fonts for variety ([raw.githubusercontent.com](https://raw.githubusercontent.com/nostalgic-css/NES.css/develop/.github/README-zh-CN.md#:~:text=via%20CDN%20,Press%20Start%202P%5D%28https%3A%2F%2Ffonts.google.com%2Fspecimen%2FPress%2BStart)), but we’ll likely stick to one font to maintain consistency. 
- **Color Palette:** Retro games often had a limited color palette due to hardware constraints. We will define a palette of maybe 8-16 colors for our app. This includes a good neutral background (possibly a dark navy or black for a classic terminal look, or a light gray/beige for a softer look), a few vibrant accent colors (like a bright green or purple for highlights, reminiscent of old GUI highlight colors), and maybe one or two alert colors (red for errors). For example, we might use a **Bubblegum 16** palette or similar which has a range of pastel and bold colors that work well together ([How to Create Retro Color Palettes for Your Pixel Art Game: A Practical Guide | by Ansimuz | Medium](https://medium.com/@ansimuz/how-to-create-retro-color-palettes-for-your-pixel-art-game-a-practical-guide-7beae8ee9c97#:~:text=A%20good%20palette%20is%20essential%2C,your%20art%20with%20unnecessary%20shades)). A key technique is to use different shades of the same base color to create depth while staying within a small palette ([How to Create Retro Color Palettes for Your Pixel Art Game: A Practical Guide | by Ansimuz | Medium](https://medium.com/@ansimuz/how-to-create-retro-color-palettes-for-your-pixel-art-game-a-practical-guide-7beae8ee9c97#:~:text=Here%E2%80%99s%20a%20trick%20to%20make,adding%20texture%20to%20large%20areas)) – e.g., use a lighter purple for a button’s highlight and a darker purple for its shadow, rather than introducing new colors. This gives a cohesive look and that “limited colors” retro feel. We should avoid gradients or modern shadow effects; instead, any shading can be done with flat darker colors or dithering patterns (although we likely won’t get into complex pixel art techniques like dithering for UI components, as it might be overkill). 
- **Layout and Imagery:** We’ll embrace blocky layouts. Containers and cards will have sharp, rectangular borders (no rounded corners unless intentionally mimicking a specific console style – but classic NES style is mostly sharp corners). We might use a **1px or 2px solid border** (Tailwind can do `border-2`) in a high-contrast color (like black or white) around panels and buttons to simulate the crisp edges of old UI. Additionally, adding a “drop shadow” effect can be done by layering borders – for instance, a container might have a black border on the top and left edges and a lighter border on the bottom and right edges, giving a pseudo-3D inset look that was common in retro windowing systems. We can achieve this with CSS by using multiple borders or pseudo-elements. Tailwind can be extended for such effects, or we manually craft a small CSS. 
- **Icons and Visuals:** Small pixel art icons can enhance the theme. For example, a vote button could have a pixelated thumbs-up icon, or the results could be accompanied by a trophy or star icon in pixel art. We can either find free pixel art icons or create simple ones (a 16x16 checkmark, a trash can icon for delete in ring management, etc.). These should be inserted as images or inline SVGs. If scaled up, ensure to use `image-rendering: pixelated` so they don’t blur. The Retro UI library example image below shows pixel stars and the pixel font in use ([GitHub - Dksie09/RetroUI: A simple pixelated UI library](https://github.com/Dksie09/RetroUI)). We will incorporate similar whimsical pixel graphics (like sparkles, borders, etc.) to give the interface a game-like personality.  
 ([GitHub - Dksie09/RetroUI: A simple pixelated UI library](https://github.com/Dksie09/RetroUI)) *Example of retro-style branding with pixelated font and icons. Our design system will use an 8-bit font and simple pixel art elements to recreate a nostalgic UI, while Tailwind CSS ensures consistency and responsiveness.*  

- **Responsive Considerations:** While retro UIs were on tiny 320x240 screens, our app still needs to work on modern large displays *and* possibly mobile. We can still be responsive: Tailwind can help adjust padding/margins on larger screens. The pixel-art nature means we likely fix base font size small (Press Start 2P at 14px gives a very blocky text) but on high DPI screens it will still be sharp. We might scale the entire interface up on larger screens using CSS transforms or just letting it reflow. It’s okay if there’s a lot of whitespace on big monitors – part of the aesthetic could be a centered “game window” with a solid background color or subtle grid pattern behind (like in the image, there’s a faint grid). We can implement such a background grid or pattern via a tiled image or CSS pattern to further emulate an old CRT monitor feel. 
- **Smooth UX in Retro Skin:** “Polished and smooth UX” means we take modern web best practices but dress them in retro clothing. That includes things like clear visual feedback on interactions (e.g., when a button is hovered or focused, change its color or add a pressed-in effect), using modal dialogs for confirmations (styled like old game dialog boxes), and ensuring keyboard accessibility (the user should be able to tab through form fields and buttons — we might even show a custom focus outline that’s a pixelated rectangle). Tailwind’s utility classes (and plugins like @tailwindcss/forms) can be used to style form elements in a retro way (for instance, making input fields look like old text boxes with a flat color and border). We should also use consistent spacing and sizing that align to an 8px or 4px grid to mimic pixel alignment. 

Overall, the design system will be documented so that any new component can follow the same style rules. We might create a style guide in the docs or README: listing the colors (with hex codes and purpose), the font usage, and examples of UI components. This ensures that as the project grows, developers maintain the retro aesthetic consistently. 

## Sample Retro-Style UI Components  
To illustrate the design system in action, here are a few key UI components in our pixel-art style, along with how we implement them (likely in the `packages/ui` library). Each component is built with Tailwind CSS classes, possibly with a bit of custom CSS for pixel-specific needs. We aim for reusable components that can be used across the app’s pages. 

- **Button:** Our Button component will look like an old-school game menu button. For example, a purple rectangular button with a darker purple border and pixelated text. We might use Tailwind classes such as: `px-4 py-2 bg-purple-600 text-white font-press-start border-2 border-black` (if we had a black outline). To give it a 3D pressed effect, we can add an inner shadow: one trick is to have a pseudo-element or an additional border on hover that shifts colors. Another simpler approach: define two styles, “normal” and “active”, where active (on click) inverts the border colors (making the top/left border dark and bottom/right light to mimic a pressed look). Using Tailwind’s group-hover or active variants, we can achieve this. The result: when the user clicks, the button appears to depress. The Button component will be used for actions like “Vote”, “Create”, “Save”, etc. It should also be accessible (have an `onClick` handler passed in, and allow keyboard press via `button` element semantics). We ensure the focus outline is custom: e.g., Tailwind `focus:outline-none` to remove default, and then add our own style – maybe an 1px dashed outline in a contrasting color to show focus in a retro way.  

- **Modal (Popup Dialog):** For confirmations or settings overlays, a Modal component is useful. A retro modal can be styled like a classic dialog window. We can create a semi-opaque backdrop (even though old systems didn’t always have overlays, it’s a modern convenience we keep). The modal box itself could be a grey box with a thick border. For instance, a div with `bg-gray-100 border-4 border-black p-4` and maybe a title in the Press Start font. We might decorate the corners with small pixel-art ornaments (like the “corner” pieces in some NES UI that look like screws or bolts – though that requires images or more CSS). Inside the modal, text is displayed in our pixel font, and actions like OK/Cancel are our Button components. An example use-case is when closing a proposal: “Are you sure you want to close voting? [Yes] [No]”. The modal appears, user clicks Yes or No, and it disappears. The modal component can be implemented as a React component that renders `children` content and has props for visibility and an onClose callback. Tailwind can handle the styling, but we might add a tiny CSS for an 8-bit drop-shadow effect (like a shadow made of a few offset layers of border). 

- **Card/Panel:** Throughout the app, we have container panels (for example, a Proposal card in the list, or a Ring card in management). A Card component can provide a stylized container with the retro border and background. Perhaps a light background with a darker border. We might style it with `border-2 border-gray-800 bg-gray-50 rounded-none` (no border radius to keep corners sharp). To add flair, we can include a header area with a bold color bar (some old UIs had window title bars). For instance, the card title (like proposal title) could be on a dark blue strip at the top of the card with white pixel text, emulating a window title bar. The rest of the card body is lighter. This can be done by structure: Card component with `title` prop that if present, renders a `<div className="bg-blue-800 text-white px-2">Title</div>` at top. The Card’s children content goes below. We can reuse this for various panels (settings sections, etc.). 

- **Input Field:** Forms need text inputs that match our theme. We can create a styled Input component, or just apply Tailwind classes via a CSS base. For instance, `input` elements could be given `bg-gray-200 border-2 border-black text-gray-800 font-mono text-sm px-2 py-1` to look like an old text field. We might even choose to make the input text monospaced or the same Press Start font (though that font in inputs might be hard to read, so maybe use a simpler pixel-esque font for inputs, or a normal sans-serif if needed for legibility). We ensure that on focus, the input gets a noticeable outline (maybe an inverted border color). Tailwind’s `focus:ring` utilities could be leveraged by customizing ring color to a pixelated-looking outline (though ring gives a blurred shadow by default, which we don’t want). Instead, maybe apply another border or change border color on focus. 

- **Layout Components:** Not a specific UI element, but we might define some utility styles in Tailwind config, such as a container class that applies our max width and centers content, as well as perhaps a CSS for the background grid. A layout might consist of a fixed-width central panel (like 600px wide) with margins auto, to mimic how old games had a specific resolution viewport. Or we allow fluid width but with our design elements repeating. 

Because we are using Tailwind, much of this can be done with utility classes on the fly. However, to avoid repetition and make it semantic, packaging them into components (in the `ui` library) is wise. For example, a `<RetroButton variant="primary" ...>` could encapsulate the classes and variant logic for normal vs primary (different colors). Similarly, a `<Dialog>` component can combine the Modal and Button for a consistent look. 

Our design system documentation (which can live in a markdown file in the repo or the docs app) will include examples of these components, showing what classes and styles they use. This acts as a guide for developers to extend the UI. For inspiration, one can look at frameworks like NES.css or RetroUI which have predefined styles for buttons, dialogs, etc., and we have essentially implemented similar ideas tailored to our app ([GitHub - Dksie09/RetroUI: A simple pixelated UI library](https://github.com/Dksie09/RetroUI#:~:text=%2A%20Pixelated%2C%20retro,Customizable%20with%20Tailwind%20CSS)). 

**Polishing Touches:** Lastly, we pay attention to details like cursor styles (maybe use the default arrow cursor, since that’s also retro; or a custom pixelated cursor icon), transitions (old UIs didn’t have smooth fades, so we might avoid modern animation, or deliberately make any animation stepwise to keep the feel), and sounds (outside the scope of CSS, but a fun idea is to play a “bleep” sound on button clicks for full retro effect – though that’s an enhancement for later!). 

With these components and styles, the Ringable app will look like a piece of software from the late 80s, but underneath it runs modern cryptography and web tech. The result is a secure anonymous voting tool that feels both novel and nostalgically familiar. 

## Conclusion (Next Steps)  
In this guide, we covered how to implement **Ringable** in a Turborepo setup, integrating **Nostringer** ring signatures for anonymity and using **Zustand** for client-side state persistence. We also outlined a retro-inspired design system to make the app visually stand out. With the above structure, a developer can begin coding each part: setting up the monorepo, implementing state stores, adding the Nostringer WASM files and calling them in vote logic, and styling components with Tailwind to match the pixel-art theme. 

This foundation is comprehensive for an MVP. Future enhancements could include multi-device vote sharing (e.g., broadcasting votes via a Nostr relay or server so multiple users can truly participate), encryption of stored private keys for security, more elaborate vote types (ranked choice, etc.), and adding more retro UI flourishes (animations, sounds). Thanks to the modular design (separating crypto, state, and UI), these features can be added without breaking the core. 

By following this implementation and design guide, you should be able to create **Ringable**: a fun yet powerful anonymous voting platform that marries advanced cryptographic privacy ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=Built%20using%20pure%20Rust%20crypto,secp256k1%20keys%20used%20in%20Nostr)) with the charm of a classic video game interface. Enjoy building and may your votes remain forever secret! 

**Sources:** The Nostringer library documentation was referenced for understanding ring signature functionality ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=A%20linkable%20variant%20that%3A)) ([Nostringer — Rust auth library // Lib.rs](https://lib.rs/crates/nostringer#:~:text=import%20init%2C%20,nostringer.js)), Zustand docs for state persistence ([zustand/docs/integrations/persisting-store-data.md at main · pmndrs/zustand · GitHub](https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#:~:text=20)), and various retro UI resources for design inspiration ([How to Create Retro Color Palettes for Your Pixel Art Game: A Practical Guide | by Ansimuz | Medium](https://medium.com/@ansimuz/how-to-create-retro-color-palettes-for-your-pixel-art-game-a-practical-guide-7beae8ee9c97#:~:text=Here%E2%80%99s%20a%20trick%20to%20make,adding%20texture%20to%20large%20areas)) ([raw.githubusercontent.com](https://raw.githubusercontent.com/nostalgic-css/NES.css/develop/.github/README-zh-CN.md#:~:text=via%20CDN%20,Press%20Start%202P%5D%28https%3A%2F%2Ffonts.google.com%2Fspecimen%2FPress%2BStart)).